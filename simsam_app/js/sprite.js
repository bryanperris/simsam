// Generated by CoffeeScript 1.12.7
(function() {
  var SpriteFactory, c_cloneRule, c_sproutRule, setSpriteTypeDraggable,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  c_sproutRule = 2;

  c_cloneRule = 1;

  window.GenericSprite = (function(superClass) {
    extend(GenericSprite, superClass);

    function GenericSprite(spriteId) {
      var myHeight, myWidth, sWidth, shapeParams;
      this.spriteId = spriteId;
      this.uniqueId = '';
      this.spriteTypeId = -1;
      this.stateTranspose = false;
      this.stateRecording = false;
      this.stateRandom = false;
      this.randomRange = 15;
      this.ruleTempObject = null;
      this.tempRandom = false;
      this.tempRandomRange = 15;
      this.prepObj = {};
      this.prePrepObj = {};
      this.countElement = null;
      sWidth = this.spriteType * 5;
      this.uniqueId = generateUUID();
      if (this.imageObj.dataset.origHeight !== void 0) {
        myHeight = this.imageObj.dataset.origHeight;
      } else {
        myHeight = this.imageObj.clientHeight;
      }
      if (this.imageObj.dataset.origWidth !== void 0) {
        myWidth = this.imageObj.dataset.origWidth;
      } else {
        myWidth = this.imageObj.clientWidth;
      }
      myWidth = parseInt(myWidth);
      myHeight = parseInt(myHeight);
      shapeParams = {
        height: myHeight,
        width: myWidth,
        borderColor: "rgb(37,58,79)",
        cornerColor: "rgb(37,58,79)",
        transparentCorners: false,
        cornerSize: 20
      };
      GenericSprite.__super__.constructor.call(this, this.imageObj, shapeParams);
    }

    GenericSprite.prototype.setSpriteTypeId = function(type) {
      if (type >= 0 || type !== 'undefined') {
        this.spriteType = type;
        return true;
      } else {
        return false;
      }
    };

    GenericSprite.prototype.getSpriteTypeId = function() {
      return this.spriteType;
    };

    GenericSprite.prototype.isRandom = function() {
      var action;
      if (this._rules.length && this._rules[0] !== void 0) {
        action = this._rules[0].action;
        return action.stateRandom;
      }
      return this.stateRandom;
    };

    GenericSprite.prototype.showRandom = function() {
      if (this.stateTranspose) {
        return this.tempRandom;
      }
      return this.isRandom();
    };

    GenericSprite.prototype.setRandom = function(value) {
      var action;
      if (this.stateTranspose) {
        this.tempRandom = value;
        return;
      }
      this.stateRandom = value;
      if (this._rules.length && this._rules[0] !== void 0) {
        action = this._rules[0].action;
        return action.stateRandom = value;
      }
    };

    GenericSprite.prototype.setRandomRange = function(range) {
      if (this.stateTranspose) {
        this.tempRandomRange = range;
        return;
      }
      return this.randomRange = range;
    };

    GenericSprite.prototype.isEditing = function() {
      return this.stateRecording;
    };

    GenericSprite.prototype.interactionEvent = function(obj) {
      var surviveObj;
      if (this.stateTranspose) {
        console.log("Error: interactionEvent called during Transpose");
        return;
      }
      console.log('Received interaction between ' + this + ' and ' + obj);
      console.log('This.id = ' + this.spriteType);
      console.log('Obj.id = ' + obj.spriteType);
      this.stateRecording = false;
      this.ruleTempObject = obj;
      this.stateTranspose = true;
      surviveObj = this;
      return uiInteractionChoose(this, function(choice) {
        return surviveObj.interactionCallback(choice);
      });
    };

    GenericSprite.prototype.interactionCallback = function(choice) {
      var r;
      console.log('interaction Choice = ' + choice + ' Line 118 sprite.coffee');
      if (choice !== 'close' && window.interactionFirst) {
        window.interactionFirst = false;
        this.clearIRules();
        console.log("rules cleared");
      }
      if (choice === 'transpose') {
        this.stateTranspose = true;
        this.initState = getObjectState(this);
        return this.stateRecording = false;
      } else if (choice === 'close') {
        this.stateTranspose = false;
        this.stateRecording = false;
        return this.showNormal();
      } else if (choice === 'clone') {
        r = new OverlapInteraction(this.ruleTempObject);
        r.addClone();
        return this.addIRule(r, this.ruleTempObject.spriteType);
      } else if (choice === 'delete') {
        r = new OverlapInteraction(this.ruleTempObject);
        r.addDelete();
        this.addIRule(r, this.ruleTempObject.spriteType);
        this.stateRecording = false;
        this.stateTranspose = false;
        return this.showNormal();
      }
    };

    GenericSprite.prototype.applyRules = function(environment) {
      var j, len, ref, results, rule;
      console.log('--Regular Rules');
      ref = this._rules;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        rule = ref[j];
        if (rule === void 0) {
          continue;
        }
        console.log('applying rule' + rule);
        results.push(rule.act(this, environment));
      }
      return results;
    };


    /*
    prepIRules: (environment) ->
        for spriteTypeKey, ruleSet of @_irules
            for setKey, rule of ruleSet
                console.log('Rule = '+rule)
                if rule == undefined
                    continue
                console.log('@prepObj = '+@prepObj)
                @prepObj = this
                @prepObj[spriteTypeKey] = rule.prep(this, environment)
                 * Latch if we are still interacting with the same object 
                if @prepObj[spriteTypeKey] == @prePrepObj[spriteTypeKey]
                    @prepObj[spriteTypeKey] = null
                else if @prepObj[spriteTypeKey] == false
                    @prePrepObj[spriteTypeKey] = null
     */

    GenericSprite.prototype.prepIRules = function(environment) {
      var self;
      console.log('applyToRuleArray');
      self = this;
      return applyToRuleArray(this._irules, (function(x, y, z) {
        return self._prepIRules(x, y, z);
      }), environment);
    };

    GenericSprite.prototype._prepIRules = function(rule, spriteTypeKey, environment) {
      if (rule === void 0) {
        return True;
      }
      this.prepObj[spriteTypeKey] = rule.prep(this, environment);
      if (this.prepObj[spriteTypeKey] === this.prePrepObj[spriteTypeKey]) {
        return this.prepObj[spriteTypeKey] = null;
      } else if (this.prepObj[spriteTypeKey] === false) {
        return this.prePrepObj[spriteTypeKey] = null;
      }
    };

    GenericSprite.prototype.applyIRules = function(environment) {
      var ref, ruleSet, self, spriteTypeKey;
      console.log('--Interaction Rules[' + this._irules.length);
      self = this;
      applyToRuleArray(this._irules, (function(x, y, z) {
        return self._applyIRules(x, y, z);
      }), environment);
      ref = this._irules;
      for (spriteTypeKey in ref) {
        ruleSet = ref[spriteTypeKey];
        if (this.prepObj[spriteTypeKey]) {
          this.prePrepObj[spriteTypeKey] = this.prepObj[spriteTypeKey];
        }
        this.prepObj[spriteTypeKey] = null;
      }
      return this.historyTick();
    };

    GenericSprite.prototype._applyIRules = function(rule, spriteTypeKey, environment) {
      if (this.countElement) {
        this.countElement.interactCheck();
      }
      console.log('Applying an iRule');
      console.log(JSON.stringify(rule, null, true));
      rule.act(this, this.prepObj[spriteTypeKey], environment);
      return true;
    };

    GenericSprite.prototype.addRule = function(rule) {
      this._rules[0] = rule;
      rule.action.stateRandom = this.stateRandom;
      window.save();
      return this._rules.length - 1;
    };

    GenericSprite.prototype.setRule = function(spriteType, rule) {
      var ruleIntType;
      ruleIntType = rule.typeint;
      this._rules[spriteType][ruleIntType] = rule;
      return window.save();
    };

    GenericSprite.prototype.addIRule = function(rule, spriteType) {
      var ruleIntType;
      ruleIntType = rule.typeint;
      if (typeof this._irules[spriteType] !== 'object' || !Array.isArray(this._irules[spriteType])) {
        this._irules[spriteType] = [];
      }
      this.constructor.addClassIRule(rule, spriteType);
      window.save();
      return this._irules.length - 1;
    };

    GenericSprite.prototype.clearIRules = function() {
      return this.clearClassIRules();
    };

    GenericSprite.prototype.addSimpleClone = function() {
      var r;
      console.log('Adding Simple Clone');
      r = new Rule();
      r.setActionType('clone');
      return this.setRule(c_cloneRule, r);
    };

    GenericSprite.prototype.removeClone = function() {
      console.log('Removing Clone');
      return delete this._rules[c_cloneRule];
    };

    GenericSprite.prototype.isClone = function() {
      if (this._rules[0] !== void 0 && typeof this._rules[0].type === 'clone') {
        return true;
      }
      return false;
    };

    GenericSprite.prototype.addSprout = function() {
      var r;
      r = new Rule();
      r.setActionType('sprout');
      return this.setRule(c_sproutRule, r);
    };

    GenericSprite.prototype.setSproutTarget = function(targetValue) {
      var r;
      r = this._rules[c_sproutRule];
      return r.action.setTarget(targetValue);
    };

    GenericSprite.prototype.getSproutTarget = function() {
      var r;
      r = this._rules[c_sproutRule];
      return r.action.getTarget();
    };

    GenericSprite.prototype.removeSprout = function() {
      if (this._rules[c_sproutRule] !== void 0 && this._rules[c_sproutRule].type === 'sprout') {
        return delete this._rules[c_sproutRule];
      }
    };

    GenericSprite.prototype.isSprout = function() {
      if (this._rules[c_sproutRule] !== void 0 && typeof this._rules[c_sproutRule].type === 'sprout') {
        return true;
      }
      return false;
    };

    GenericSprite.prototype.learningToggle = function() {
      var endState, r, ref;
      console.log((ref = 'learningToggle was: ' + this.stateRecording) != null ? ref : {
        'true': 'false'
      });
      if (this.stateTranspose) {
        this.stateTranspose = false;
        this.showNormal();
        endState = getObjectState(this);
        r = new OverlapInteraction(this.ruleTempObject);
        r.setActionType('transform');
        r.addTransform(this.initState, endState);
        if (this.tempRandom) {
          r.addRandom(this.tempRandomRange);
          this.tempRandom = false;
        }
        this.addIRule(r, this.ruleTempObject.spriteType);
        return;
      }
      if (!this.stateRecording) {
        this.initState = getObjectState(this);
        this.showLearning();
        return this.stateRecording = true;
      } else {
        endState = getObjectState(this);
        this.showNormal();
        if (!g_recordingClone) {
          r = new Rule(this.spriteType);
          r.setActionType('transform');
          r.addTransform(this.initState, endState);
          if (this.isRandom()) {
            r.addRandom(this.randomRange);
          }
          this.addRule(r);
        }
        this.stateRecording = false;
        return window.save();
      }
    };

    GenericSprite.prototype.showLearning = function() {
      this.set({
        borderColor: "rgb(98,192,4)",
        cornerColor: "rgb(98,192,4)",
        transparentCorners: false
      });
      return canvas.renderAll();
    };

    GenericSprite.prototype.showNormal = function() {
      this.set({
        borderColor: "rgb(37,58,79)",
        cornerColor: "rgb(37,58,79)",
        transparentCorners: false
      });
      return canvas.renderAll();
    };

    GenericSprite.prototype.trueIntersectsWithObject = function(obj) {
      if (this.intersectsWithObject(obj)) {
        return true;
      }
      if (this.isContainedWithinObject(obj)) {
        return true;
      }
      if (obj.isContainedWithinObject(this)) {
        return true;
      }
      return false;
    };

    GenericSprite.prototype.isOnCanvas = function() {
      var bound, canvas, height, width;
      canvas = $('#container');
      height = $(canvas).height();
      width = $(canvas).width();
      bound = this.getBoundingRect();
      if ((bound.width + bound.left) < 0) {
        return false;
      }
      if ((bound.height + bound.top) < 0) {
        return false;
      }
      if (bound.left > width) {
        return false;
      }
      if (bound.top > height) {
        return false;
      }
      return true;
    };

    GenericSprite.prototype.removeFromList = function() {
      var idx;
      idx = spriteList.indexOf(this);
      if (idx >= 0) {
        spriteList.splice(idx, 1);
        return this.subtractCount();
      }
    };

    GenericSprite.prototype.remove = function() {
      if (this.countElement !== null) {
        this.countElement.remove();
        this.countElement = null;
      }
      return GenericSprite.__super__.remove.call(this);
    };

    GenericSprite.prototype.modified = function() {
      if (this.countElement !== null) {
        this.countElement.update();
        return canvas.renderAll();
      }
    };

    GenericSprite.prototype.saveToJSON = function() {
      var fabricJSON, jsonObj, ref;
      jsonObj = {};
      fabricJSON = JSON.stringify(this.toJSON());
      jsonObj['fabric'] = fabricJSON;
      jsonObj['uniqueId'] = this.uniqueId;
      jsonObj['stateTranspose'] = this.stateTranspose;
      jsonObj['stateRecording'] = this.stateRecording;
      jsonObj['stateRandom'] = this.stateRandom;
      jsonObj['randomRange'] = this.randomRange;
      jsonObj['tempRandom'] = this.tempRandom;
      jsonObj['tempRandomRange'] = this.tempRandomRange;
      jsonObj['countElement'] = (ref = this.countElement === null) != null ? ref : {
        '0': '1'
      };
      jsonObj['spriteType'] = this.spriteType;
      return jsonObj;
    };

    GenericSprite.prototype.restoreFromJSON = function(json) {
      var fabricObj;
      fabricObj = JSON.parse(json['fabric']);
      this.constructor.fromObject(fabricObj);
      this._initConfig(fabricObj);
      canvas.add(this);
      console.log("Rest L: " + this.getLeft() + " T: " + this.getTop());
      this.uniqueId = json['uniqueId'];
      this.stateTranspose = false;
      this.stateRecording = false;
      this.stateRandom = json['stateRandom'];
      this.randomRange = json['randomRange'];
      this.spriteType = json['spriteType'];
      return this.setCoords();
    };

    return GenericSprite;

  })(fabric.Image);

  SpriteFactory = function(spriteType, imageObj) {
    var Sprite;
    console.log("sprite factory" + spriteType + imageObj.src);
    Sprite = (function(superClass) {
      extend(Sprite, superClass);

      console.log("class sprite");

      Sprite.prototype.spriteType = spriteType;

      Sprite.prototype.imageObj = imageObj;

      Sprite.prototype.hash = imageObj.dataset.hash;

      Sprite.prototype._rules = [];

      Sprite.prototype._irules = [];

      Sprite.prototype._count = 0;

      Sprite.prototype._history = [];

      Sprite.prototype.cloneTranslate = {
        top: 0,
        left: 0,
        rotate: 0
      };

      Sprite.prototype.cloneFrequency = 100;

      function Sprite(spriteType) {
        var chash, hash;
        Sprite.prototype._count = Sprite.prototype._count + 1;
        hash = this.imageObj.dataset['hash'];
        $('#' + hash).html(Sprite.prototype._count);
        this.myOpt = JSON.parse(JSON.stringify(window.sparkOpt));
        this.myOpt['width'] = '22px';
        chash = '#' + 'chart-' + hash;
        $(chash).sparkline(Sprite.prototype._history, this.myOpt);
        Sprite.__super__.constructor.call(this, spriteType);
      }

      Sprite.prototype.subtractCount = function() {
        var chash, hash;
        Sprite.prototype._count = Sprite.prototype._count - 1;
        hash = this.imageObj.dataset['hash'];
        $('#' + hash).html(Sprite.prototype._count);
        chash = '#' + 'chart-' + hash;
        return $(chash).sparkline(Sprite.prototype._history, this.myOpt);
      };

      Sprite.prototype.getHistory = function() {
        return Sprite.prototype._history;
      };

      Sprite.prototype.clearHistory = function() {
        return Sprite.prototype._history = [];
      };

      Sprite.prototype.historyTick = function() {
        var chash, hash;
        Sprite.prototype._history.push(Sprite.prototype._count);
        hash = this.imageObj.dataset['hash'];
        $('#' + hash).html(Sprite.prototype._count);
        chash = '#' + 'chart-' + hash;
        return $(chash).sparkline(Sprite.prototype._history, this.myOpt);
      };

      Sprite.addClassRule = function(rule, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        return Sprite.prototype._rules[idx] = rule;
      };

      Sprite.addClassIRule = function(rule, spriteTypeKey) {
        var ruleIntType;
        if (Sprite.prototype._irules[spriteTypeKey] === void 0) {
          Sprite.prototype._irules[spriteTypeKey] = [];
        }
        if (spriteTypeKey === void 0) {
          spriteTypeKey = 0;
        }
        ruleIntType = rule.typeint;
        return Sprite.prototype._irules[spriteTypeKey][ruleIntType] = rule;
      };

      Sprite.prototype.clearClassIRules = function() {
        var idx, ref, results, rule;
        ref = Sprite.prototype._irules;
        results = [];
        for (idx in ref) {
          rule = ref[idx];
          results.push(Sprite.prototype._irules[idx] = []);
        }
        return results;
      };

      Sprite.prototype.setCloneOffset = function(topVal, leftVal, rotate) {
        Sprite.prototype.cloneTranslate.top = topVal;
        Sprite.prototype.cloneTranslate.left = leftVal;
        return Sprite.prototype.cloneTranslate.rotate = rotate;
      };

      Sprite.prototype.setCloneFrequency = function(freq) {
        return Sprite.prototype.cloneFrequency = freq;
      };

      Sprite.prototype.reset = function() {
        Sprite.prototype.clearHistory();
        Sprite.prototype._irules = [];
        return Sprite.prototype._rules = [];
      };

      return Sprite;

    })(GenericSprite);
    return Sprite;
  };

  window.spriteList = [];

  window.spriteTypeList = {};

  window.spriteDeleteList = [];

  window.textList = [];

  window.tick = function() {
    var j, k, l, len, len1, len2, len3, len4, m, n, sprite;
    for (j = 0, len = spriteList.length; j < len; j++) {
      sprite = spriteList[j];
      sprite.applyRules();
    }
    for (k = 0, len1 = spriteList.length; k < len1; k++) {
      sprite = spriteList[k];
      sprite.prepIRules();
    }
    for (l = 0, len2 = spriteList.length; l < len2; l++) {
      sprite = spriteList[l];
      sprite.applyIRules();
    }
    for (m = 0, len3 = spriteList.length; m < len3; m++) {
      sprite = spriteList[m];
      if (!sprite.isOnCanvas()) {
        spriteDeleteList.push(sprite);
      }
    }
    for (n = 0, len4 = spriteDeleteList.length; n < len4; n++) {
      sprite = spriteDeleteList[n];
      sprite.removeFromList();
      sprite.remove();
    }
    canvas.renderAll.bind(canvas);
    return canvas.renderAll();
  };

  setSpriteTypeDraggable = function(sprite, input_type) {
    return $(sprite).draggable({
      revert: false,
      helper: function(e) {
        var el, target;
        target = e.target;
        el = document.createElement('img');
        el.src = target.src;
        return el;
      },
      cursorAt: {
        top: 0,
        left: 0
      },
      start: function(e, ui) {
        return $(ui.helper).addClass("ui-draggable-helper");
      },
      stop: function(ev, ui) {
        var dropX, dropY, newSprite, st, type;
        type = input_type;
        if (pointWithinElement(ev.pageX, ev.pageY, $('#trash_menu_button')) || pointWithinElement(ev.pageX, ev.pageY, $('#trash'))) {
          console.log('I am within the Trash Sprite Button');
          deleteImageFully(type, this);
          return;
        }
        console.log('I am a ' + type);
        dropX = ev.pageX - window.globalPos.left;
        dropY = ev.pageY - window.globalPos.top;
        st = getSpriteType(type);
        if (st.prototype._count >= window.maxSprites) {
          return;
        }
        console.log('Before new window.spriteTypeList[i]' + type);
        newSprite = new st;
        console.log('After new window.spriteTypeList[i]' + type);
        console.log('SpriteType Success? = ' + newSprite.setSpriteTypeId(type));
        spriteList.push(newSprite);
        newSprite.setTop(ev.pageY);
        newSprite.setLeft(dropX);
        canvas.add(newSprite);
        canvas.renderAll();
        return window.save();
      }
    });
  };

  window.addOneSprite = function(hash, sprite) {
    var mySpriteType;
    mySpriteType = SpriteFactory(hash, sprite);
    window.spriteTypeList[hash] = mySpriteType;
    return setSpriteTypeDraggable(sprite, hash);
  };

  window.loadSpriteTypes = function() {
    window.maxSprites = 25;
    console.log("loading sprite types");
    window.spriteTypeList = {};
    $("#sprite_drawer > img").each(function(i, sprite) {
      var hash;
      hash = sprite.getAttribute('data-hash');
      console.log("loading sprite type" + hash);
      sprite.setAttribute('data-sprite-type', hash);
      sprite.setAttribute('data-debug', 'lST');
      console.log('Adding sprite with hash: ' + hash);
      window.addOneSprite(hash, sprite);
      return setSpriteTypeDraggable(sprite, hash);
    });
    console.log("--- Loaded sprite type list: " + Object.keys(window.spriteTypeList).length);
    return window.spriteTypesLoaded = true;
  };

  window.saveSprites = function() {
    var irulesSub, j, k, key, l, len, len1, len2, masterObj, obj, objects, oneType, ref, rule, ruleJSON, string, textElements, type, typeObjects;
    masterObj = {};
    typeObjects = [];
    for (key in spriteTypeList) {
      type = spriteTypeList[key];
      oneType = {};
      oneType.type = type.prototype.spriteType;
      oneType.imageObj = type.prototype.imageObj.src;
      oneType.count = type.prototype._count;
      oneType.rules = [];
      oneType.cloneTranslate = type.prototype.cloneTranslate;
      oneType.cloneFrequency = type.prototype.cloneFrequency;
      ref = type.prototype._rules;
      for (j = 0, len = ref.length; j < len; j++) {
        rule = ref[j];
        if (rule === void 0) {
          continue;
        }
        ruleJSON = rule.toJSON();
        oneType.rules.push(ruleJSON);
      }
      irulesSub = [];
      ruleBuildJSON(type.prototype._irules, irulesSub);
      oneType.irules = irulesSub;
      typeObjects.push(oneType);
    }
    masterObj.classObjects = typeObjects;
    objects = [];
    for (k = 0, len1 = spriteList.length; k < len1; k++) {
      obj = spriteList[k];
      objects.push(obj.saveToJSON());
    }
    masterObj.objects = objects;
    textElements = [];
    for (l = 0, len2 = textList.length; l < len2; l++) {
      obj = textList[l];
      textElements.push(obj.saveToJSON());
    }
    masterObj.textElements = textElements;
    string = JSON.stringify(masterObj);
    $('#data').html(JSON.stringify(masterObj, null, 4));
    return string;
  };

  window.clearEverything = function() {
    var j, k, l, len, len1, len2, len3, len4, m, n, ref, ref1, ref2, sprite, spriteType, text, tmpList, tmpTextList;
    tmpList = [];
    ref = window.spriteList;
    for (j = 0, len = ref.length; j < len; j++) {
      sprite = ref[j];
      tmpList.push(sprite);
    }
    for (k = 0, len1 = tmpList.length; k < len1; k++) {
      sprite = tmpList[k];
      sprite.removeFromList();
      sprite.remove();
    }
    tmpTextList = [];
    ref1 = window.textList;
    for (l = 0, len2 = ref1.length; l < len2; l++) {
      text = ref1[l];
      tmpTextList.push(text);
    }
    for (m = 0, len3 = tmpTextList.length; m < len3; m++) {
      text = tmpTextList[m];
      if (text.group !== void 0) {
        canvas.remove(text.group);
      }
    }
    window.textList = [];
    ref2 = window.spriteTypeList;
    for (n = 0, len4 = ref2.length; n < len4; n++) {
      spriteType = ref2[n];
      spriteType.prototype.reset();
    }
    return canvas.renderAll();
  };

  window.loadSprites = function(dataString) {
    var foundMatch, idx, imageObjects, img, imgSrc, inObject, iruleData, j, k, l, len, len1, len2, len3, len4, m, n, newSprite, newText, obj, ref, ref1, ref2, ref3, ref4, ref5, rule, ruleData, ruleJSON, ruleTypeKey, spriteTypeKey, txt, typeFactory, typeObj;
    inObject = JSON.parse(dataString);
    if (inObject.classObjects.length === 0 && inObject.objects.length === 0) {
      return;
    }
    window.spriteTypeList = {};
    clearEverything();
    imageObjects = [];
    $("#sprite_drawer > img").each(function(i, sprite) {
      var hash;
      hash = sprite.getAttribute('data-hash');
      console.log("loading sprite type" + hash);
      imageObjects.push(this);
      setSpriteTypeDraggable(sprite, hash);
      sprite.setAttribute('data-sprite-type', hash);
      return sprite.setAttribute('data-debug', 'lS');
    });
    ref = inObject.classObjects;
    for (j = 0, len = ref.length; j < len; j++) {
      typeObj = ref[j];
      foundMatch = false;
      imgSrc = typeObj.imageObj;
      for (k = 0, len1 = imageObjects.length; k < len1; k++) {
        img = imageObjects[k];
        console.log("ImgSrc: " + imgSrc + " img.src: " + img.src);
        if (imgSrc === img.src) {
          typeObj.raw = img;
          foundMatch = true;
          break;
        }
      }
      console.log('typeObj.type = ' + typeObj.type + ' typeObj.raw = ' + typeObj.raw);
      if (!foundMatch) {
        console.log('Object appeared in our save, but the type does not.' + ' We are ignoring this object.');
        continue;
      }
      typeFactory = SpriteFactory(typeObj.type, typeObj.raw);
      typeFactory.prototype._count = 0;
      typeFactory.prototype.cloneTranslate = typeObj.cloneTranslate;
      typeFactory.prototype.cloneFreqency = typeObj.cloneFreqency;
      ref1 = typeObj.rules;
      for (idx in ref1) {
        ruleData = ref1[idx];
        rule = Rule.createFromData(ruleData);
        typeFactory.addClassRule(rule, idx);
      }
      ref2 = typeObj.irules;
      for (spriteTypeKey in ref2) {
        iruleData = ref2[spriteTypeKey];
        for (ruleTypeKey in iruleData) {
          ruleJSON = iruleData[ruleTypeKey];
          if (ruleJSON === null) {
            continue;
          }
          rule = Rule.createFromData(ruleJSON);
          typeFactory.addClassIRule(rule, spriteTypeKey);
        }
      }
      window.spriteTypeList[typeObj.type] = typeFactory;
    }
    $("#sprite_drawer > img").each(function(i, sprite) {
      var hash, matched;
      hash = sprite.getAttribute('data-hash');
      matched = hash in window.spriteTypeList;
      if (!matched) {
        return window.addOneSprite(hash, sprite);
      }
    });
    ref3 = inObject.objects;
    for (l = 0, len2 = ref3.length; l < len2; l++) {
      obj = ref3[l];
      newSprite = makeSpriteOfType(obj.spriteType);
      newSprite.restoreFromJSON(obj);
      window.spriteList.push(newSprite);
    }
    if (inObject.textElements !== void 0) {
      ref4 = inObject.textElements;
      for (m = 0, len3 = ref4.length; m < len3; m++) {
        txt = ref4[m];
        newText = new TextLabel('Default');
        newText.restoreFromJSON(txt);
      }
    }
    console.log("---- Here are our sprites ----");
    ref5 = window.spriteTypeList;
    for (n = 0, len4 = ref5.length; n < len4; n++) {
      obj = ref5[n];
      if (obj.src !== void 0) {
        console.log(obj.src());
      }
    }
    canvas.renderAll();
    return window.spriteTypesLoaded = true;
  };

  window.getSpriteType = function(type) {
    var idx, spriteType;
    for (idx in spriteTypeList) {
      spriteType = spriteTypeList[idx];
      if (spriteType.prototype.spriteType === type) {
        console.log("getSpriteType[" + idx + "]: " + type);
        return spriteType;
      }
    }
    return void 0;
  };

  window.makeSpriteOfType = function(type) {
    var st;
    st = getSpriteType(type);
    return new st;
  };

}).call(this);
